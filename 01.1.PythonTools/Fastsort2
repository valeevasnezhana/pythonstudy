#include <stdio.h>

#define NMAX 10

int input(int* a);
void output(int* a);
void copy_data(int* input_a, int* output_a, int size);
void heap_sort(int* a);
void merge_sort(int* a);
void merge_sort_internal(int* a, int *temp_data, int start_index_inclusive, int end_index_exclusive);
void merge_two_sub_arrays(int* a, int *temp_data, int start_index_inclusive, int middle_index, int end_index_exclusive);

int main() {
    int data[NMAX];
    if (input(data) == 0) {
        int data_for_second_sort[NMAX];
        copy_data(data, data_for_second_sort, NMAX);

        heap_sort(data);
        output(data);

        merge_sort(data_for_second_sort);
        output(data_for_second_sort);
    } else {
        printf("n/a");
    }
    return 0;
}

int input(int* a) {
    for (int* p = a; p - a < NMAX; p++) {
        if (scanf("%d", p) != 1) {
            return 1;
        }
    }
    if (getchar() != 10) {
        return 1;
    }
    return 0;
}

void output(int* a) {
    for (int* p = a; p - a < NMAX; p++) {
        printf("%d", *p);
        if ((p - a) < NMAX - 1) {
            printf(" ");
        } else {
            printf("\n");
        }
    }
}

void copy_data(int* input_a, int* output_a, int size) {
    for (int i = 0; i < size; i++) {
        output_a[i] = input_a[i];
    }
}

void merge_sort(int* a) {
    int temp_data[NMAX];
    merge_sort_internal(a, temp_data, 0, NMAX);
}

void merge_sort_internal(int* a, int *temp_data, int start_index_inclusive, int end_index_exclusive) {
    if (start_index_inclusive < (end_index_exclusive - 1)) {
        int middle_index = (end_index_exclusive + start_index_inclusive) / 2;
        merge_sort_internal(a, temp_data, start_index_inclusive, middle_index);
        merge_sort_internal(a, temp_data, middle_index, end_index_exclusive);
        merge_two_sub_arrays(a, temp_data, start_index_inclusive, middle_index, end_index_exclusive);
    }
}

void merge_two_sub_arrays(int* a, int *temp_data, int start_index_inclusive, int middle_index, int end_index_exclusive) {
    int output_index = 0;
    int left_index = start_index_inclusive;
    int right_index = middle_index;

    while (left_index < middle_index && right_index < end_index_exclusive) {
        if (a[left_index] < a[right_index]) {
            temp_data[output_index] = a[left_index];
            left_index++;
            output_index++;
        } else {
            temp_data[output_index] = a[right_index];
            right_index++;
            output_index++;
        }
    }
    while (left_index < middle_index) {
        temp_data[output_index] = a[left_index];
        left_index++;
        output_index++;
    }
    while (right_index < end_index_exclusive) {
        temp_data[output_index] = a[right_index];
        right_index++;
        output_index++;
    }

    for (int i = start_index_inclusive; i < end_index_exclusive; i++) {
        a[i] = temp_data[i - start_index_inclusive];
    }
}

void swap_two_elements(int* a, int left, int right) {
    int tmp = a[left];
    a[left] = a[right];
    a[right] = tmp;
}

void create_max_heap_inside_array(int* a, int size) {
    for (int k = 0; k < size; k++) {
        int current_index = k;
        int parent_index = (current_index - 1) / 2;
        while (((current_index - 1) / 2 >= 0) && (a[current_index] > a[parent_index])) {
            swap_two_elements(a, current_index, parent_index);
            current_index = parent_index;
            parent_index = (current_index - 1) / 2;
        }
    }
}

void restore_heap(int* a, int heap_last_index_non_inclusive) {
        int current_index = 0;
        while (current_index < heap_last_index_non_inclusive) {
            int left_child_index = current_index * 2 + 1;
            int right_child_index = current_index * 2 + 2;
            if (left_child_index >= heap_last_index_non_inclusive && right_child_index >= heap_last_index_non_inclusive) {
                break;
            }
            int chosen_child_index;
            if (left_child_index < heap_last_index_non_inclusive && right_child_index >= heap_last_index_non_inclusive) {
                chosen_child_index = left_child_index;
            } else if (left_child_index > heap_last_index_non_inclusive && right_child_index < heap_last_index_non_inclusive) {
                chosen_child_index = right_child_index;
            } else {
                if (a[left_child_index] > a[right_child_index]) {
                    chosen_child_index = left_child_index;
                } else {
                    chosen_child_index = right_child_index;
                }
            }
            if (a[chosen_child_index] > a[current_index]) {
                swap_two_elements(a, current_index, chosen_child_index);
                current_index = chosen_child_index;
            } else {
                break;
            }
        }
}

void heap_sort(int* a) {
    create_max_heap_inside_array(a, NMAX);
    for (int k = 0; k < NMAX; k++) {
        int heap_last_index_non_inclusive = (NMAX - 1) - k;
        swap_two_elements(a, 0, heap_last_index_non_inclusive);
        restore_heap(a, heap_last_index_non_inclusive);
    }
}
