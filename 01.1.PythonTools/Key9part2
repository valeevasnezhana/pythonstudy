#include <stdio.h>

#define LEN 100

void sum(int* buff1, int len1, int* buff2, int len2, int* result, int* result_length);

void sub(int* buff1, int len1, int* buff2, int len2, int* result, int* result_length);

int fill_with_value(int* buff, int len, int value);

int get_value_or_zero(int* buff, int index);

int get_max_value(int left_value, int right_value);

/*
    Беззнаковая целочисленная длинная арифметика
    с использованием массивов.
    Ввод:
     * 2 длинных числа в виде массивов до 100 элементов
     * В один элемент массива нельзя вводить число > 9
    Вывод:
     * Результат сложения и разности чисел-массивов
    Пример:
     * 1 9 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 6 1
       2 9

       1 9 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 9 0
       1 9 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 3 2
*/
void input(int* buff, int* len) {
    int current_index = 0;
    char input_char = getchar();
    while (input_char != '\n') {
        if (input_char != ' ') {
            buff[current_index] = input_char - '0';
            current_index++;
        }
        input_char = getchar();
    }
    *len = current_index;
}

void output(int* buff, int len) {
    if (len < 0) {
        printf("n/a\n");
    } else {
        int non_zero_number_already_printed = 0;
        for (int i = 0; i < len; i++) {
            if (buff[i] <= 0 && non_zero_number_already_printed == 0) {
                // Skipping empty leading numbers
                continue;
            }
            non_zero_number_already_printed = 1;
            printf("%d", buff[i]);
            if (i < (len-1)) {
                printf(" ");
            }
        }
        printf("\n");
    }
}

int main() {
    int len1 = -1;
    int len2 = -1;
    int buff1[LEN];
    int buff2[LEN];

    input(buff1, &len1);
    input(buff2, &len2);

    int sum_len = -1;
    int sum_buff[LEN];
    sum(buff1, len1, buff2, len2, sum_buff, &sum_len);
    output(sum_buff, sum_len);

    int substr_len = -1;
    int substr_buff[LEN];
    sub(buff1, len1, buff2, len2, substr_buff, &substr_len);
    output(substr_buff, substr_len);
}

void sum(int* buff1, int len1, int* buff2, int len2, int* result, int* result_length) {
    int max_len = get_max_value(len1, len2);
    *result_length = max_len + 1;
    fill_with_value(result, *result_length, -1);
    int remaining = 0;
    for (int index = 0; index < *result_length; index++) {
        int left_index = (len1 - index - 1);
        int right_index = (len2 - index - 1);

        int left_value = get_value_or_zero(buff1, left_index);
        int right_value = get_value_or_zero(buff2, right_index);

        int current_sum = left_value + right_value + remaining;
        int new_remaining = current_sum / 10;
        int output_digit = current_sum % 10;
        remaining = new_remaining;

        result[*result_length-index-1] = output_digit;
    }
}

void sub(int* buff1, int len1, int* buff2, int len2, int* result, int* result_length) {
    int max_len = get_max_value(len1, len2);
    *result_length = max_len + 1;
    fill_with_value(result, *result_length, -1);
    int remaining = 0;
    for (int index = 0; index < max_len; index++) {
        int left_index = (len1 - index - 1);
        int right_index = (len2 - index - 1);

        int left_value = get_value_or_zero(buff1, left_index);
        int right_value = get_value_or_zero(buff2, right_index);

        int current_sub = left_value - right_value + remaining;
        int output_digit;
        int new_remaining;
        if (current_sub < 0) {
            output_digit = 10 + current_sub;
            new_remaining = -1;
        } else {
            new_remaining = 0;
            output_digit = current_sub % 10;
        }
        remaining = new_remaining;
        result[*result_length-index-1] = output_digit;
    }
    if (remaining < 0) {
        *result_length = -1;
    }
}

int get_value_or_zero(int* buff, int index) {
    int output_value;
    if (index < 0) {
        output_value = 0;
    } else {
        output_value = buff[index];
    }
    return output_value;
}

int get_max_value(int left_value, int right_value) {
    int output_max_value;
    if (left_value > right_value) {
        output_max_value = left_value;
    } else {
        output_max_value = right_value;
    }
    return output_max_value;
}

int fill_with_value(int* buff, int len, int value) {
    for (int i = 0; i < len; i++) {
        buff[i] = value;
    }
}
