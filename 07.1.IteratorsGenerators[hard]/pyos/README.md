## Simple OS with multitasking

`OS design` `syscall` `cooperative multitasking` `generator` `coroutine`

### Цель

Вам нужно написать простенький шедулер для операционной системы, который бы работал с задачами в режиме
кооперативной многозадачности.

Ограничения и упрощения:
- код на питоне (никакой низкоуровневой магии на си/ассемблере)
- без тредов
- без сабпроцессинга
- generator-based корутины

Зачем? Чтобы потрогать корутины, а также получить базовое представление о том, как устроены операционные системы.
А также некоторый шаг в сторону понимания, как работает асинхронность в питоне (об этом подробнее на следующих лекциях).

### Устройство ОС "на пальцах"

#### Многозадачность
На уровне одного ядра процессора любая программа - это всего лишь набор инструкций, при выполнении которых
*не существует возможности* делать более одного действия одновременно.

Процессор ничего не знает о многозадачности (с точки зрения того, что такое задача, и когда между ними следует
переключаться), как и приложения. Но кому-то нужно об этом знать! И знает об этом операционная системма (ОС).

ОС (Windows, Linux или MacOS) отвечает за запуск приложений на вашем компьютере.
И именно она позволяет держать запущенными более одного приложения за раз (многозадачность).
ОС реализует видимость работы нескольких приложений одновременно за счет постоянного быстрого и частого
переключения между отдельными задачами.

Но как именно ОС переключается между задачами? Как она дает понять процессору, что пришло время сменить задачу A на
задачу B, и как сама операционная система понимает, что пришло это время?

Существует 2 механизма, которые дают ОС возможность управлять задачами:
- прерывания (interrupts), т.е. некоторые аппаратные средства, посылающие сигналы процессору (примеры:
сработал таймер, нажата клавиша на клавиатуре, пришли данные по сети и с жесткого диска и т.д. и т.п.)
- ловушки (traps), а это в свою очередь программные сигналы, которые генерируют те или иные приложения, либо сама
операционная система (для управления поведением приложений)

В обоих случаях процессор прерывает выполнение текущего кода и запускает код ОС для обработки входящего события, и
именно в этот момент ОС может принять решение и сменить текущую задачу.

Причем прерывания и ловушки - это единственный способ взаимодействия с операционной системой для приложения,
поэтому все, т.н. системные вызовы (syscall) - это не что иное, как инструкция для процессора, которая генерирует
прерывание, после чего процессор автоматически прерывает выполнение задачи и запускает код ОС для обработки события.
А когда событие обработано, выполнение задачи продолжается с того же места (возможно, не сразу, могли успеть
поисполняться другие задачи). Также задача может получить ответ на свой запрос от ОС (обычно он лежит на стеке или
доступен в регистрах процессора).

Помимо добровольных прерываний, когда программа хочет провзаимодействовать с операционной системой, периодически
происходят прерывания выполнения программы по таймеру, запускается специальный код операционной системы (планировщик),
и может заменить текущую задачу на другую. Этот механизм называется преемптивной (англ. preemtive) или вытесняющей
многозадачностью. Задачей планировщика является отслеживание времени выполнения задач и переключение между ними,
согласно их приоритету. Современные планировщики внутри ОС довольно сложны, но в простейшем случае это может быть
обычная очередь без приоритета (например, в данной задаче).

В нашей задаче мы не будем использовать таймер для переключения задач. Воспользуемся другим механизмом - механизмом
кооперативной многозадачности. Кооперативная многозадачность в отличие от вытесняющей строится на том, что только
конкретная задача (процесс) знает, когда её эффективнее всего прерывать, например, если прямо сейчас она ожидает
получения данных по сети, и ничего полезного до этого момента сделать не в состоянии. В таком случае задача может
самостоятельно уступить выполнение в пользу другой задачи. Более того, это единственный способ переключения между
задачами, поэтому если какая-то задача злоупотребит доверием и будет крутиться в вечном цикле, ожидая данные, вместо
того, чтобы запросить замену, пока она ждет, то никакая другая задача не сможет быть выполнена, и смысла в такой
"многозадачности" будет немного.

Данный способ, очевидно, не подходит для ОС, в которой должны уживаться множество независимых программ, в том числе
потенциально зловредных (помним про вирусы, да и просто кривой и бажный код), но в рамках одной программы,
исходный код которой находится в руках одного программиста (одной команды), этот подход к многозадачности может
оказаться гораздо эффективнее, т.к. переключения между задачами происходят только в тот момент, когда в них есть
смысл (а любое переключение между задачами довольно дорого, т.к. требует сохранить/восстановить контекст).

#### Корутины для организации кооперативной многозадачности
Окей, кооперативная многозадачность - это круто, а причем тут питон?

Если вы внимательно слушали лекцию про генераторы, то возможно, вы обратили внимание, что yield для генераторов является
самым что ни на есть прерыванием (прерыванием выполнения генератора). Т.е. если интерпретатор встречает в коде
yield, то он немедленно прерывает выполнение данного генератора, возвращает наружу некоторое значение, а после по
запросу управляющего кода (запустившего генератор) может продолжить выполнение генератора.

То есть, если предположить, что код, который запускает генераторы - это некоторый код операционной системы, а
код внутри самих генераторов - это задачи, то получается, что можно построить некоторую упрощенную "операционную
систему" на чистом питоне!

Конечно, вам не нужно будет писать целую операционную систему, только лишь упрощенный планировщик задач и некоторую
обертку над генераторами, которая станет интерфейсом к генератору для вашего планировщика.

Допустим, а причем тут корутины? Да и в реальной операционной системе есть вот эти все syscall'ы и прочая муть,
oh wait!...

Да, если вспомнить, что генераторы в питоне позволяют не только возвращать значения, но и передавать объекты
внутрь генератора, то можно воспользоваться этим, и договориться, что в рамках нашей задачи, генераторы должны
возвращать опреденные объекты (системные вызовы), которые позволят коду планировщика понять, чего от него хочет
данная задача (генератор) и сделать это! Такие генераторы мы и будем называть корутинами. Результат выполнения
системного вызова наш планировщик будет отправлять обратно в корутину, таким образом мы получим для корутин
интерфейс взаимодействия, аналогичный настоящей ОС!

### Интерфейс для взаимодействия планировщика и задач

Итак, в рамках данной задачи мы вводим 3 основных объекта, которые вам необходимо реализовать:
- SystemCall
- Task
- Scheduler

#### SystemCall
Системный вызов будет представлять из себя объект, с единственным методом `handle`, который будет вызываться
планировщиком для совершения запрошенного действия.

```python
@abstractmethod
def handle(self, scheduler: 'Scheduler', task: 'Task') -> bool:
    """
    :param scheduler: link to scheduler to manipulate with active tasks
    :param task: task which requested the system call
    :return: an indication that the task must be scheduled again
    """
```

#### Task
Объект-обертка над корутиной (кодом задачи), который предоставляет планировщику интерфейс для пошагового запуска
(до ближайшего yield в коде корутины), а также хранит результат последнего системного вызова для передачи его
внутрь корутины (через `.send`).

```python
def step(self) -> Optional[SystemCall]:
    """
    Performs one step of coroutine, i.e. sends result of last system call
    to coroutine (generator), gets yielded value and returns it.
    """
```

#### Scheduler
Основной класс, описывающий планировщик, содержит публичное апи, которое используется в тестах (`new` / `run` / `empty`),
и приватное апи, которое "доступно" только из методов самого планировщика и из системных вызовов (`*_task`).

Публичное апи состоит из 3-х методов, 1 из которых уже реализован для вас и используется в тестах, а 2 других
вам нужно реализовать самостоятельно.

`new` создает и возвращает id созданной задачи:

```python
def new(self, target: Coroutine) -> int:
    """Create and schedule new task
    :param target: coroutine to wrap in task
    :return: id of newly created task
    """
```

`run` запускает исполнение задач на N тиков (где тик - это 1 запуск метода `step` у задачи):

```python
def run(self, ticks: Optional[int] = None) -> None:
    """Executes tasks consequentely, gets yielded system calls,
    handles them and reschedules task if needed
    :param ticks: number of iterations (task steps), infinite if not passed
    """
```

### Рекомендации по решению

Для начала реализуйте класс `Task`, который должен хранить переданную корутину и порядковый номер. Класс должен
предоставлять метод `step`, который возобновляет выполнение корутины, передав в нее результат последнего системного
вызова (результат вызова хранится в задаче и обновляется планировщиком извне).

Затем начните реализовывать класс `Scheduler`, для начала вам хватит методов `new` / `_schedule_task` / `run`. Обратите
внимание на конструктор класса, его реализации вам должно хватить для решения задания (но можете его поменять
при желании).

Метод `new` по сути является оберткой над конструктором задачи, который еще и сохраняет задачу в планировщике, а
также планирует её для выполнения (`_schedule_task`).

Задача метода `_schedule_task` всего лишь положить задачу в очередь.

Метод `run` в первом приближении должен уметь извлекать задачу из очереди, запустить её метод `step`,
и положить задачу обратно в конец очереди.

Этого вам должно хватить, чтобы пройти следующий тест.

Затем вам нужно будет поменять реализацию метода `run` так, чтобы он умел работать с задачами, которые завершаются,
а не выполняются бесконечно.

Здесь обратите внимание на тест `test_schedule_non_cooperative_tasks`, который наглядно демонстрирует, что будет,
если в коде, рассчитанном на кооперативную многозадачность, забить на переключение в коде самих задачах.

Так итеративно продолжайте модифицировать ваш код, пока не получите работающее решение.

Когда дойдете до системных вызовов, вам нужно будет научиться определять, что задача вернула вам объект `SystemCall`,
выполнить его обработчик и сохранить результат в задаче для того, чтобы позже передать его в корутину.

В общем-то и все, еще стоит обратить внимание на комментарии в тестах и коде, они подсказывают про пару граблей, на
которые вы можете наступить. Удачи!

### Про задачу

Эта задача призвана продемонстрировать, как устроен планировщик задач в ОС, а также поможет вам в дальнейшем понимать,
как работает кооперативная многозадачность, и почему важно в асинхронном коде явно указывать точки переключения
между задачами (`yield`, а в дальнейшем `yield from` и `await`).
